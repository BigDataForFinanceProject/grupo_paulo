[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An√°lise de Dados Financeiros",
    "section": "",
    "text": "Seja bem-vindo(a) √† nossa p√°gina! Aqui, apresentamos nossa an√°lise sobre os ativos financeiros de algumas das principais empresas brasileiras. Utilizamos metodologias estat√≠sticas e computacionais para explorar tend√™ncias e insights valiosos para investidores e analistas do mercado financeiro. üî•üìà\n\n\nNosso grupo √© composto por entusiastas da ci√™ncia de dados e do mercado financeiro. Confira abaixo nossas p√°ginas individuais:\n\nLuis Almeida\nCleto Ribas\nPaulo Folly\n\n\n\n\nPara nossa an√°lise, escolhemos um conjunto de dados robusto proveniente de APIs especializadas em dados financeiros, como Yahoo! Finance. Os ativos analisados pertencem a grandes empresas do mercado de capitais brasileiro:\n‚úÖ VALE3.SA - Vale S.A. (Setor de Minera√ß√£o)  ‚úÖ PETR3.SA - Petrobras (Setor de Energia e Petr√≥leo)  ‚úÖ WEGE3.SA - Weg S.A. (Setor Industrial e Tecnologia)  ‚úÖ GGBR4.SA - Gerdau (Setor de Siderurgia e Metalurgia)  ‚úÖ ITUB4.SA - Ita√∫ Unibanco (Setor Banc√°rio e Financeiro) \nUtilizamos bibliotecas como pandas, yfinance, matplotlib e seaborn para coletar, processar e visualizar os dados de forma interativa e intuitiva. üí°üìä\n\n\n\nNosso primeiro post sobre a an√°lise de dados est√° dispon√≠vel! Nele, apresentamos a motiva√ß√£o do projeto, os primeiros passos da an√°lise e algumas previs√µes interessantes sobre os ativos escolhidos.\n\n\n\nNesta se√ß√£o, analisamos os log-retornos dos ativos financeiros escolhidos. Para visualizar e executar o c√≥digo completo, acesse o link abaixo:\nüîó Clique aqui para abrir no Google Colab\nOs gr√°ficos e an√°lises s√£o gerados diretamente no Colab, permitindo intera√ß√£o com os dados de forma din√¢mica."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html#integrantes-do-grupo",
    "href": "index.html#integrantes-do-grupo",
    "title": "An√°lise de Dados Financeiros",
    "section": "",
    "text": "Nosso grupo √© composto por entusiastas da ci√™ncia de dados e do mercado financeiro. Confira abaixo nossas p√°ginas individuais:\n\nLuis Almeida\nCleto Ribas\nPaulo Folly"
  },
  {
    "objectID": "index.html#conjunto-de-dados",
    "href": "index.html#conjunto-de-dados",
    "title": "An√°lise de Dados Financeiros",
    "section": "",
    "text": "Para nossa an√°lise, escolhemos um conjunto de dados robusto proveniente de APIs especializadas em dados financeiros, como Yahoo! Finance. Os ativos analisados pertencem a grandes empresas do mercado de capitais brasileiro:\n‚úÖ VALE3.SA - Vale S.A. (Setor de Minera√ß√£o)  ‚úÖ PETR3.SA - Petrobras (Setor de Energia e Petr√≥leo)  ‚úÖ WEGE3.SA - Weg S.A. (Setor Industrial e Tecnologia)  ‚úÖ GGBR4.SA - Gerdau (Setor de Siderurgia e Metalurgia)  ‚úÖ ITUB4.SA - Ita√∫ Unibanco (Setor Banc√°rio e Financeiro) \nUtilizamos bibliotecas como pandas, yfinance, matplotlib e seaborn para coletar, processar e visualizar os dados de forma interativa e intuitiva. üí°üìä"
  },
  {
    "objectID": "index.html#publica√ß√£o-do-projeto",
    "href": "index.html#publica√ß√£o-do-projeto",
    "title": "An√°lise de Dados Financeiros",
    "section": "",
    "text": "Nosso primeiro post sobre a an√°lise de dados est√° dispon√≠vel! Nele, apresentamos a motiva√ß√£o do projeto, os primeiros passos da an√°lise e algumas previs√µes interessantes sobre os ativos escolhidos."
  },
  {
    "objectID": "index.html#an√°lise-de-log-retornos",
    "href": "index.html#an√°lise-de-log-retornos",
    "title": "An√°lise de Dados Financeiros",
    "section": "",
    "text": "Nesta se√ß√£o, analisamos os log-retornos dos ativos financeiros escolhidos. Para visualizar e executar o c√≥digo completo, acesse o link abaixo:\nüîó Clique aqui para abrir no Google Colab\nOs gr√°ficos e an√°lises s√£o gerados diretamente no Colab, permitindo intera√ß√£o com os dados de forma din√¢mica."
  },
  {
    "objectID": "BIG_DATA_FOR_FINANCE_PROJECT.html",
    "href": "BIG_DATA_FOR_FINANCE_PROJECT.html",
    "title": "pasta_projeto_grupo",
    "section": "",
    "text": "# Instalar a biblioteca yfinance, caso ainda n√£o esteja instalada\n!pip install yfinance\n\nimport yfinance as yf\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definir os tickers das a√ß√µes\ntickers = ['VALE3.SA', 'PETR3.SA', 'WEGE3.SA', 'GGBR4.SA', 'ITUB4.SA', 'BBDC4.SA']\n\n# Baixar dados hist√≥ricos de pre√ßos\ndados = {}\nfor ticker in tickers:\n    dados[ticker] = yf.download(ticker, start='2020-01-01', end='2025-03-21')\n\n# Calcular log-retornos\nlog_retornos = {}\nfor ticker, df in dados.items():\n    df['Log_Returns'] = np.log(df['Close']) - np.log(df['Close'].shift(1))\n    log_retornos[ticker] = df['Log_Returns']\n\n# Plotar histogramas dos log-retornos\ndef plotar_histogramas(log_retornos):\n    for ticker, retornos in log_retornos.items():\n        plt.figure(figsize=(10, 6))\n        plt.hist(retornos.dropna(), bins=50, alpha=0.75, color='blue', edgecolor='black')\n        plt.title(f'Histograma de Log-Retornos para {ticker}')\n        plt.xlabel('Log-Retornos')\n        plt.ylabel('Frequ√™ncia')\n        plt.grid(True)\n        plt.show()\n\nplotar_histogramas(log_retornos)\n\n# An√°lise estat√≠stica b√°sica\nfor ticker, retornos in log_retornos.items():\n    media = retornos.mean()\n    variancia = retornos.var()\n    print(f\"An√°lise para {ticker}:\")\n    print(f\"  M√©dia dos log-retornos: {media:.6f}\")\n    print(f\"  Vari√¢ncia dos log-retornos: {variancia:.6f}\\n\")\n\nRequirement already satisfied: yfinance in /usr/local/lib/python3.11/dist-packages (0.2.55)\nRequirement already satisfied: pandas&gt;=1.3.0 in /usr/local/lib/python3.11/dist-packages (from yfinance) (2.2.2)\nRequirement already satisfied: numpy&gt;=1.16.5 in /usr/local/lib/python3.11/dist-packages (from yfinance) (2.0.2)\nRequirement already satisfied: requests&gt;=2.31 in /usr/local/lib/python3.11/dist-packages (from yfinance) (2.32.3)\nRequirement already satisfied: multitasking&gt;=0.0.7 in /usr/local/lib/python3.11/dist-packages (from yfinance) (0.0.11)\nRequirement already satisfied: platformdirs&gt;=2.0.0 in /usr/local/lib/python3.11/dist-packages (from yfinance) (4.3.7)\nRequirement already satisfied: pytz&gt;=2022.5 in /usr/local/lib/python3.11/dist-packages (from yfinance) (2025.1)\nRequirement already satisfied: frozendict&gt;=2.3.4 in /usr/local/lib/python3.11/dist-packages (from yfinance) (2.4.6)\nRequirement already satisfied: peewee&gt;=3.16.2 in /usr/local/lib/python3.11/dist-packages (from yfinance) (3.17.9)\nRequirement already satisfied: beautifulsoup4&gt;=4.11.1 in /usr/local/lib/python3.11/dist-packages (from yfinance) (4.13.3)\nRequirement already satisfied: soupsieve&gt;1.2 in /usr/local/lib/python3.11/dist-packages (from beautifulsoup4&gt;=4.11.1-&gt;yfinance) (2.6)\nRequirement already satisfied: typing-extensions&gt;=4.0.0 in /usr/local/lib/python3.11/dist-packages (from beautifulsoup4&gt;=4.11.1-&gt;yfinance) (4.12.2)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in /usr/local/lib/python3.11/dist-packages (from pandas&gt;=1.3.0-&gt;yfinance) (2.8.2)\nRequirement already satisfied: tzdata&gt;=2022.7 in /usr/local/lib/python3.11/dist-packages (from pandas&gt;=1.3.0-&gt;yfinance) (2025.1)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /usr/local/lib/python3.11/dist-packages (from requests&gt;=2.31-&gt;yfinance) (3.4.1)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in /usr/local/lib/python3.11/dist-packages (from requests&gt;=2.31-&gt;yfinance) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /usr/local/lib/python3.11/dist-packages (from requests&gt;=2.31-&gt;yfinance) (2.3.0)\nRequirement already satisfied: certifi&gt;=2017.4.17 in /usr/local/lib/python3.11/dist-packages (from requests&gt;=2.31-&gt;yfinance) (2025.1.31)\nRequirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=1.3.0-&gt;yfinance) (1.17.0)\nYF.download() has changed argument auto_adjust default to True\n\n\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn√°lise para VALE3.SA:\n  M√©dia dos log-retornos: 0.000413\n  Vari√¢ncia dos log-retornos: 0.000538\n\nAn√°lise para PETR3.SA:\n  M√©dia dos log-retornos: 0.001016\n  Vari√¢ncia dos log-retornos: 0.000865\n\nAn√°lise para WEGE3.SA:\n  M√©dia dos log-retornos: 0.000831\n  Vari√¢ncia dos log-retornos: 0.000573\n\nAn√°lise para GGBR4.SA:\n  M√©dia dos log-retornos: 0.000320\n  Vari√¢ncia dos log-retornos: 0.000695\n\nAn√°lise para ITUB4.SA:\n  M√©dia dos log-retornos: 0.000162\n  Vari√¢ncia dos log-retornos: 0.000405\n\nAn√°lise para BBDC4.SA:\n  M√©dia dos log-retornos: -0.000419\n  Vari√¢ncia dos log-retornos: 0.000550\n\n\n\n\n# prompt: plote um grafico de valoriza√ßao das a√ßoes, usando o retorno percentual, ou seja normalizando todos os ativos iniciando a como se fosse valendo 1 para que as linhas nos graficos fiquem na mesma escala\n\nimport yfinance as yf\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ... (c√≥digo anterior permanece inalterado)\n\n# Calcular o retorno percentual normalizado\nretornos_normalizados = {}\nfor ticker, df in dados.items():\n    df['Retorno_Normalizado'] = df['Close'] / df['Close'].iloc[0]\n    retornos_normalizados[ticker] = df['Retorno_Normalizado']\n\n# Plotar o gr√°fico de valoriza√ß√£o das a√ß√µes\nplt.figure(figsize=(12, 6))\nfor ticker, retornos in retornos_normalizados.items():\n    plt.plot(retornos.index, retornos, label=ticker)\n\nplt.title('Valoriza√ß√£o das A√ß√µes (Normalizada)')\nplt.xlabel('Data')\nplt.ylabel('Retorno Normalizado')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# prompt: mostre a valoriza√ßao numa tabela em percentual de cada ativo\n\nimport pandas as pd\n\n# ... (c√≥digo anterior permanece inalterado)\n\n\n# Criar um DataFrame para a tabela de valoriza√ß√£o\nvalorizacao = pd.DataFrame()\n\nfor ticker, df in dados.items():\n    valorizacao[ticker] = df['Close']\n\n# Calcular a varia√ß√£o percentual em rela√ß√£o ao primeiro dia\nvalorizacao_percentual = valorizacao / valorizacao.iloc[0] * 100\n\n# Mostrar a tabela de valoriza√ß√£o percentual\nvalorizacao_percentual\n\n\n  \n    \n\n\n\n\n\n\nVALE3.SA\nPETR3.SA\nWEGE3.SA\nGGBR4.SA\nITUB4.SA\nBBDC4.SA\n\n\nDate\n\n\n\n\n\n\n\n\n\n\n2020-01-02\n100.000000\n100.000000\n100.000000\n100.000000\n100.000000\n100.000000\n\n\n2020-01-03\n99.263762\n97.530476\n98.723020\n98.362234\n98.948199\n100.050615\n\n\n2020-01-06\n98.674778\n100.701197\n98.978465\n98.121378\n97.475722\n98.263517\n\n\n2020-01-07\n99.392621\n99.329262\n99.744637\n99.662804\n95.214354\n96.556476\n\n\n2020-01-08\n99.411028\n97.713420\n95.970527\n100.048170\n93.662916\n95.062762\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n2025-03-14\n167.973045\n361.238805\n286.567744\n148.904327\n119.903240\n57.032125\n\n\n2025-03-17\n170.390131\n369.609081\n292.147055\n151.369928\n123.502789\n57.878440\n\n\n2025-03-18\n171.643444\n369.891250\n292.147055\n151.546029\n124.166777\n57.831422\n\n\n2025-03-19\n171.345031\n371.678151\n295.151274\n151.810206\n124.474318\n58.348612\n\n\n2025-03-20\n170.807910\n373.371020\n293.679820\n151.457987\n123.321069\n58.066510\n\n\n\n\n1298 rows √ó 6 columns\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n\n  \n    \n    \n\n  \n    \n  \n    \n    \n  \n\n    \n  \n\n\n\n# prompt: agora analise qual seria meu retorno percentual se eu tivesse uma carteira composta por esses ativos com pesos iguais e gere. um grafico\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n# ... (c√≥digo anterior permanece inalterado)\n\n# Calcular o retorno da carteira com pesos iguais\npesos = np.array([1/len(tickers)] * len(tickers))  # Pesos iguais para todos os ativos\ncarteira_retornos = np.sum(valorizacao_percentual.pct_change() * pesos, axis=1)\ncarteira_valorizacao = (1 + carteira_retornos.fillna(0)).cumprod() * 100 # Ajustando a valoriza√ß√£o da carteira\n\n\n# Plotar o gr√°fico de valoriza√ß√£o da carteira\nplt.figure(figsize=(12, 6))\nplt.plot(carteira_valorizacao.index, carteira_valorizacao, label='Carteira')\nplt.title('Valoriza√ß√£o da Carteira (com pesos iguais)')\nplt.xlabel('Data')\nplt.ylabel('Retorno (%)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Calcular o retorno total da carteira\nretorno_total_carteira = (carteira_valorizacao[-1] / carteira_valorizacao[0]) -1\n\n\nprint(f\"Retorno total da carteira: {retorno_total_carteira:.2f}%\")\n\n\n\n\n\n\n\n\nRetorno total da carteira: 0.98%\n\n\nFutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  retorno_total_carteira = (carteira_valorizacao[-1] / carteira_valorizacao[0]) -1\n\n\n\n# prompt: agora analise qual seria meu retorno percentual se eu tivesse uma carteira composta por esses ativos poorem cada ativo tera seu peso de acordo com seu peso nno ibovespa\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n# ... (c√≥digo anterior permanece inalterado)\n\n# Obter os pesos do Ibovespa (substitua pelo m√©todo correto para obter os pesos reais)\n# Neste exemplo, estou usando pesos aleat√≥rios para demonstra√ß√£o.\n# Voc√™ precisa substituir esta parte pelo c√≥digo que obt√©m os pesos reais do Ibovespa.\npesos_ibovespa = np.random.rand(len(tickers))\npesos_ibovespa = pesos_ibovespa / np.sum(pesos_ibovespa) # Normalizar os pesos para soma 1\n\nprint(\"Pesos do Ibovespa (exemplo - substitua por dados reais):\")\nfor i in range(len(tickers)):\n    print(f\"{tickers[i]}: {pesos_ibovespa[i]:.4f}\")\n\n\n# Calcular o retorno da carteira com os pesos do Ibovespa\ncarteira_retornos_ibovespa = np.sum(valorizacao_percentual.pct_change() * pesos_ibovespa, axis=1)\ncarteira_valorizacao_ibovespa = (1 + carteira_retornos_ibovespa.fillna(0)).cumprod() * 100\n\n# Plotar o gr√°fico de valoriza√ß√£o da carteira com pesos do Ibovespa\nplt.figure(figsize=(12, 6))\nplt.plot(carteira_valorizacao_ibovespa.index, carteira_valorizacao_ibovespa, label='Carteira (Pesos Ibovespa)')\nplt.title('Valoriza√ß√£o da Carteira (com pesos do Ibovespa)')\nplt.xlabel('Data')\nplt.ylabel('Retorno (%)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Calcular o retorno total da carteira com pesos do Ibovespa\nretorno_total_carteira_ibovespa = (carteira_valorizacao_ibovespa[-1] / carteira_valorizacao_ibovespa[0]) - 1\n\nprint(f\"Retorno total da carteira (pesos Ibovespa): {retorno_total_carteira_ibovespa:.2f}%\")\n\nPesos do Ibovespa (exemplo - substitua por dados reais):\nVALE3.SA: 0.2308\nPETR3.SA: 0.0553\nWEGE3.SA: 0.2066\nGGBR4.SA: 0.0317\nITUB4.SA: 0.1668\nBBDC4.SA: 0.3088\n\n\n\n\n\n\n\n\n\nRetorno total da carteira (pesos Ibovespa): 0.59%\n\n\nFutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  retorno_total_carteira_ibovespa = (carteira_valorizacao_ibovespa[-1] / carteira_valorizacao_ibovespa[0]) - 1\n\n\n\n# prompt: agora, usando os pesos iguais para cada ativo, por√©m fa√ßa o rebbalanceamennto da carteira para retornnarmos ao peso inicial ao final de cada mes\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n# ... (c√≥digo anterior permanece inalterado)\n\n# Rebalanceamento mensal da carteira com pesos iguais\ncarteira_valorizacao_rebalanceada = pd.Series(100, index=carteira_valorizacao.index) # Inicializa com 100\npesos_iniciais = np.array([1/len(tickers)] * len(tickers))\ninvestimentos_iniciais = 100 * pesos_iniciais\n\nfor i in range(1, len(valorizacao_percentual)):\n    if valorizacao_percentual.index[i].month != valorizacao_percentual.index[i-1].month:  # Verificar se √© um novo m√™s\n      # Calcula a valoriza√ß√£o atual de cada ativo\n      valorizacao_atual = valorizacao_percentual.iloc[i] * investimentos_iniciais\n      valor_total_carteira = valorizacao_atual.sum()\n\n      # Recalcula os investimentos para cada ativo para retornar aos pesos iniciais\n      investimentos_iniciais = valor_total_carteira * pesos_iniciais\n\n    carteira_valorizacao_rebalanceada.iloc[i] = valorizacao_percentual.iloc[i].values.dot(pesos_iniciais)\n\n\n# Plotar o gr√°fico de valoriza√ß√£o da carteira rebalanceada\nplt.figure(figsize=(12, 6))\nplt.plot(carteira_valorizacao_rebalanceada.index, carteira_valorizacao_rebalanceada, label='Carteira Rebalanceada')\nplt.title('Valoriza√ß√£o da Carteira (Rebalanceamento Mensal)')\nplt.xlabel('Data')\nplt.ylabel('Retorno (%)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n\n# Calcular o retorno total da carteira rebalanceada\nretorno_total_carteira_rebalanceada = (carteira_valorizacao_rebalanceada[-1] / carteira_valorizacao_rebalanceada[0]) - 1\n\nprint(f\"Retorno total da carteira rebalanceada: {retorno_total_carteira_rebalanceada:.2f}%\")\n\nFutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '98.81305101730302' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n  carteira_valorizacao_rebalanceada.iloc[i] = valorizacao_percentual.iloc[i].values.dot(pesos_iniciais)\n\n\n\n\n\n\n\n\n\nRetorno total da carteira rebalanceada: 0.95%\n\n\nFutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  retorno_total_carteira_rebalanceada = (carteira_valorizacao_rebalanceada[-1] / carteira_valorizacao_rebalanceada[0]) - 1\n\n\n\n# prompt: agora, usando os mesmos pesos que voce usou no exemplo, por√©m fa√ßa o rebbalanceamennto para retornnarmos ao peso do exemplo ao final de cada mes\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n# ... (c√≥digo anterior permanece inalterado)\n\n# Obter os pesos do Ibovespa (substitua pelo m√©todo correto para obter os pesos reais)\n# Neste exemplo, estou usando pesos fixos para demonstra√ß√£o.\npesos_ibovespa = np.array([0.2, 0.15, 0.15, 0.10, 0.20, 0.20]) # Exemplo de pesos fixos\nprint(\"Pesos do Ibovespa (fixos - substitua por dados reais se necess√°rio):\")\nfor i in range(len(tickers)):\n    print(f\"{tickers[i]}: {pesos_ibovespa[i]:.4f}\")\n\n# Rebalanceamento mensal\ncarteira_valorizacao_ibovespa = pd.Series(100, index=valorizacao_percentual.index) # Inicializa a s√©rie com 100\ncarteira_valor_inicial = 100\n\n\nfor i in range(1, len(valorizacao_percentual)):\n    # Verificar se √© o primeiro dia do m√™s\n    if valorizacao_percentual.index[i].day == 1:  # Ajustar para o primeiro dia do m√™s\n       # Calcular a valoriza√ß√£o atual da carteira\n        valor_atual_carteira = carteira_valorizacao_ibovespa.iloc[i-1]\n        valor_atual_ativos = valor_atual_carteira * pesos_ibovespa\n        # Rebalanceia para os pesos originais do Ibovespa\n        carteira_valorizacao_ibovespa.iloc[i] = valor_atual_carteira\n    else:\n        carteira_retornos_ibovespa = np.sum(valorizacao_percentual.iloc[i] / valorizacao_percentual.iloc[i-1] * pesos_ibovespa ) - 1\n        carteira_valorizacao_ibovespa.iloc[i] = carteira_valorizacao_ibovespa.iloc[i-1] * (1 + carteira_retornos_ibovespa)\n\n# Plotar o gr√°fico de valoriza√ß√£o da carteira com pesos do Ibovespa e rebalanceamento\nplt.figure(figsize=(12, 6))\nplt.plot(carteira_valorizacao_ibovespa.index, carteira_valorizacao_ibovespa, label='Carteira (Pesos Ibovespa - Rebalanceada)')\nplt.title('Valoriza√ß√£o da Carteira (com pesos do Ibovespa e Rebalanceamento Mensal)')\nplt.xlabel('Data')\nplt.ylabel('Retorno (%)')\nplt.legend()\nplt.grid(True)\nplt.show()\n\n# Calcular o retorno total da carteira com pesos do Ibovespa e rebalanceamento\nretorno_total_carteira_ibovespa = (carteira_valorizacao_ibovespa[-1] / carteira_valorizacao_ibovespa[0]) - 1\nprint(f\"Retorno total da carteira (pesos Ibovespa - Rebalanceada): {retorno_total_carteira_ibovespa:.2f}%\")\n\nPesos do Ibovespa (fixos - substitua por dados reais se necess√°rio):\nVALE3.SA: 0.2000\nPETR3.SA: 0.1500\nWEGE3.SA: 0.1500\nGGBR4.SA: 0.1000\nITUB4.SA: 0.2000\nBBDC4.SA: 0.2000\n\n\nFutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '98.92676299853862' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n  carteira_valorizacao_ibovespa.iloc[i] = carteira_valorizacao_ibovespa.iloc[i-1] * (1 + carteira_retornos_ibovespa)\n\n\n\n\n\n\n\n\n\nRetorno total da carteira (pesos Ibovespa - Rebalanceada): 0.54%\n\n\nFutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n  retorno_total_carteira_ibovespa = (carteira_valorizacao_ibovespa[-1] / carteira_valorizacao_ibovespa[0]) - 1"
  }
]